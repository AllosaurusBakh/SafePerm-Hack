import t,{useContext as e,useState as n,useRef as o,useEffect as s}from"react";function r(){return r=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(t[o]=n[o])}return t},r.apply(this,arguments)}const a=(t,e)=>{const n={};for(const o in t)-1===e.indexOf(o)&&(n[o]=t[o]);return n},i=/*#__PURE__*/t.createContext(null),c=/*#__PURE__*/t.createContext(null),l=e=>n=>/*#__PURE__*/t.createElement(c.Consumer,null,o=>/*#__PURE__*/t.createElement(e,r({parent:o},n))),p=(t=[])=>{const[r,a]=n(!1),c=o(t),l=(()=>{const t=e(i);if(null===t)throw new Error("Couldn't find Yandex.Maps API in the context. Make sure that hook useYMaps is inside <YMaps /> provider");return t})(),p=l.getApi();return s(()=>{l.load().then(()=>Promise.all(c.current.map(l.loadModule))).then(()=>a(!0))},[]),r&&p?p:null},u=()=>{},m=["onLoad","onError","modules","apiLoader"];function d(e,n=!1,o=[]){return i=>{const{width:c,height:l,modules:d=[],onLoad:h=u}=i,f=p(o.concat(d)),y=!n||!!f,b=a(i,m);return s(()=>f?h(f):void 0,[f]),y?/*#__PURE__*/t.createElement(e,r({ymaps:f},b)):/*#__PURE__*/t.createElement("div",{style:{width:c,height:l}})}}const h="undefined"!=typeof window,f={lang:"ru_RU",load:"",ns:"",mode:"release"},y=e=>{const{version:n="2.1",enterprise:r=!1,query:a={lang:"ru_RU",load:"",ns:""},preload:c=!1,children:l}=e,p=o((t=>{const{query:e=f}=t,n=Date.now().toString(32),o=e.ns||"",s="__yandex-maps-api-onload__$$"+n,r="__yandex-maps-api-onerror__$$"+n,a=h?window:{},i={};let c;const l=()=>o?a[o]:c,p=()=>{delete a[s],delete a[r]};return{load:()=>{if(l())return Promise.resolve(c);if(i[o])return i[o];const n={onload:s,onerror:r,...f,...e},u=Object.keys(n).map(t=>`${t}=${n[t]}`).join("&"),m=[`https://${t.enterprise?"enterprise.":""}api-maps.yandex.ru`,t.version,"?"+u].join("/");return i[o]=new Promise((t,e)=>{a[s]=e=>{p(),e.ready(()=>{c=e,t(e)})},a[r]=t=>{p(),e(t)},(t=>new Promise((e,n)=>{const o=document.createElement("script");o.type="text/javascript",o.onload=e,o.onerror=n,o.src=t,o.async=!0,document.head.appendChild(o)}))(m).catch(a[r])}),i[o]},getApi:l,loadModule:t=>new Promise((e,n)=>{c.modules.require(t).done(n=>{n.forEach(e=>{((t,e,n,o=!1)=>{const s="string"==typeof e?e.split("."):e.slice();let r,a=t;for(;s.length>1;)r=s.shift(),a[r]||(a[r]={}),a=a[r];const i=s[0];a[i]=!0===o&&a[i]||n})(c,t,e,!0)}),e(c)},n)})}})({version:n,enterprise:r,query:a,preload:c}));return s(()=>{c&&p.current.load()},[p.current]),/*#__PURE__*/t.createElement(i.Provider,{value:p.current},l)},b=/^on(?=[A-Z])/;function v(t){return Object.keys(t).reduce((e,n)=>{if(b.test(n)){const o=n.replace(b,"").toLowerCase();e._events[o]=t[n]}else e[n]=t[n];return e},{_events:{}})}function j(t,e,n){"function"==typeof n&&t.events.add(e,n)}function O(t,e,n){"function"==typeof n&&t.events.remove(e,n)}function g(t,e,n){Object.keys(Object.assign({},e,n)).forEach(o=>{e[o]!==n[o]&&(O(t,o,e[o]),j(t,o,n[o]))})}const E=t=>"default"+t.charAt(0).toUpperCase()+t.slice(1);function C(t,e){return void 0!==t[e]||void 0===t[E(e)]}function _(t,e,n){return(C(t,e)?t[e]:t[E(e)])||n}function R(t,e,n=null){if(t!==e){if(t&&("current"in t?t.current=null:"function"==typeof t&&t(null)),!e)return;"current"in e?e.current=n:"function"==typeof e&&e(n)}}function w(t){const{width:e,height:n,style:o,className:s}=t;return void 0!==o||void 0!==s?Object.assign({},o&&{style:o},s&&{className:s}):{style:{width:e,height:n}}}class P extends t.Component{constructor(t){super(t),this.state={error:null,errorInfo:null}}componentDidCatch(t,e){const{onError:n=(()=>{})}=this.props;n(t),this.setState({error:t,errorInfo:e})}render(){return this.state.error?null:this.props.children}}const x=e=>({onError:n,...o})=>/*#__PURE__*/t.createElement(P,{onError:n},/*#__PURE__*/t.createElement(e,o));class M extends t.Component{constructor(){super(),this.instance=null,this.state={instance:null},this._parentElement=null,this._getRef=t=>{this._parentElement=t}}componentDidMount(){this.instance=M.mountObject(this._parentElement,this.props.ymaps.Map,this.props),this.setState({instance:this.instance})}componentDidUpdate(t){null!==this.instance&&M.updateObject(this.instance,t,this.props)}componentWillUnmount(){M.unmountObject(this.instance,this.props)}render(){const e=w(this.props),n=v(this.props),o=a(n,["_events","state","defaultState","options","defaultOptions","instanceRef","ymaps","children","width","height","style","className"]);/*#__PURE__*/return t.createElement(c.Provider,{value:this.state.instance},/*#__PURE__*/t.createElement("div",r({ref:this._getRef},e,o),this.props.children))}static mountObject(t,e,n){const{instanceRef:o,_events:s}=v(n),r=new e(t,_(n,"state"),_(n,"options"));return Object.keys(s).forEach(t=>j(r,t,s[t])),R(null,o,r),r}static updateObject(t,e,n){const{_events:o,instanceRef:s}=v(n),{_events:r,instanceRef:a}=v(e);if(C(n,"state")){const o=_(e,"state",{}),s=_(n,"state",{});o.type!==s.type&&t.setType(s.type),o.behaviors!==s.behaviors&&(o.behaviors&&t.behaviors.disable(o.behaviors),s.behaviors&&t.behaviors.enable(s.behaviors)),s.zoom&&o.zoom!==s.zoom&&t.setZoom(s.zoom),s.center&&o.center!==s.center&&t.setCenter(s.center),s.bounds&&o.bounds!==s.bounds&&t.setBounds(s.bounds)}if(C(n,"options")){const o=_(e,"options"),s=_(n,"options",{});o!==s&&t.options.set(s)}_(e,"width")===_(n,"width")&&_(e,"height")===_(n,"height")||t.container.fitToViewport(),g(t,r,o),R(a,s,t)}static unmountObject(t,e){const{instanceRef:n,_events:o}=v(e);null!==t&&(Object.keys(o).forEach(e=>O(t,e,o[e])),t.destroy(),R(n))}}const k=x(d(M,!0,["Map"]));k.defaultProps={width:320,height:240};class S extends t.Component{constructor(){super(),this.state={instance:null},this._parentElement=null,this._getRef=t=>{this._parentElement=t}}componentDidMount(){this._mounted=!0,this.props.ymaps.panorama.isSupported()&&S.mountObject(this._parentElement,this.props.ymaps.panorama,this.props).then(t=>this._mounted&&this.setState({instance:t}))}componentDidUpdate(t){null!==this.state.instance&&S.updateObject(this.state.instance,t,this.props)}componentWillUnmount(){this._mounted=!1,S.unmountObject(this.state.instance,this.props)}render(){const e=w(this.props);/*#__PURE__*/return t.createElement("div",r({ref:this._getRef},e))}static mountObject(t,e,n){const{instanceRef:o,_events:s}=v(n),r=_(n,"point"),a=_(n,"locateOptions"),i=_(n,"options");return new Promise((n,c)=>{e.locate(r,a).done(r=>{if(r.length>0){const a=new e.Player(t,r[0],i);R(null,o,a),Object.keys(s).forEach(t=>j(a,t,s[t])),n(a)}},c)})}static updateObject(t,e,n){const{_events:o,instanceRef:s}=v(n),{_events:r,instanceRef:a}=v(e);if(C(n,"options")){const o=_(e,"options"),s=_(n,"options");o!==s&&t.options.set(s)}if(C(n,"point")){const o=_(n,"point"),s=_(e,"point"),r=_(n,"locateOptions");o!==s&&t.moveTo(o,r)}g(t,r,o),R(a,s,t)}static unmountObject(t,e){const{instanceRef:n,_events:o}=v(e);null!==t&&(Object.keys(o).forEach(e=>O(t,e,o[e])),R(n))}}const T=x(d(S,!0,["panorama.isSupported","panorama.locate","panorama.createPlayer","panorama.Player"]));T.defaultProps={width:320,height:240};class U extends t.Component{constructor(){super(),this.state={instance:null},this.instance=null}componentDidMount(){const t=U.mountControl(this.props.ymaps.control[this.props.name],this.props);this.instance=t,this.setState({instance:t})}componentDidUpdate(t){null!==this.instance&&U.updateControl(this.instance,t,this.props)}componentWillUnmount(){U.unmountControl(this.instance,this.props)}render(){/*#__PURE__*/return t.createElement(c.Provider,{value:this.state.instance},this.props.children)}static mountControl(t,e){const{instanceRef:n,parent:o,lazy:s,_events:r}=v(e),a=new t({data:_(e,"data"),options:_(e,"options"),state:_(e,"state"),mapTypes:_(e,"mapTypes"),lazy:s});if(Object.keys(r).forEach(t=>j(a,t,r[t])),o&&o.controls&&"function"==typeof o.controls.add)o.controls.add(a);else{if(!o||!o.add||"function"!=typeof o.add)throw new Error(`No parent found to mount ${e.name}`);o.add(a)}return R(null,n,a),a}static updateControl(t,e,n){const{_events:o,instanceRef:s}=v(n),{_events:r,instanceRef:a}=v(e);if(C(n,"options")){const o=_(e,"options"),s=_(n,"options");o!==s&&t.options.set(s)}if(C(n,"data")){const o=_(e,"data"),s=_(n,"data");o!==s&&t.data.set(s)}if(C(n,"state")){const o=_(e,"state"),s=_(n,"state");o!==s&&t.state.set(s)}if(C(n,"mapTypes")){const o=_(e,"mapTypes"),s=_(n,"mapTypes");o!==s&&(t.removeAllMapTypes(),s.forEach(e=>t.addMapType(e)))}g(t,r,o),R(a,s,t)}static unmountControl(t,e){const{instanceRef:n,parent:o,_events:s}=v(e);null!==t&&(Object.keys(s).forEach(e=>O(t,e,s[e])),o.controls&&"function"==typeof o.controls.remove?o.controls.remove(t):o.remove&&"function"==typeof o.remove&&o.remove(t),R(n))}}var D=x(l(d(e=>/*#__PURE__*/t.createElement(U,r({},e,{name:"Button"})),!0,["control.Button"]))),B=x(l(d(e=>/*#__PURE__*/t.createElement(U,r({},e,{name:"FullscreenControl"})),!0,["control.FullscreenControl"]))),A=x(l(d(e=>/*#__PURE__*/t.createElement(U,r({},e,{name:"GeolocationControl"})),!0,["control.GeolocationControl"]))),L=x(l(d(e=>/*#__PURE__*/t.createElement(U,r({},e,{name:"ListBox"})),!0,["control.ListBox"]))),$=x(l(d(e=>/*#__PURE__*/t.createElement(U,r({},e,{name:"ListBoxItem"})),!0,["control.ListBoxItem"]))),N=x(l(d(e=>/*#__PURE__*/t.createElement(U,r({},e,{name:"RouteButton"})),!0,["control.RouteButton"]))),Z=x(l(d(e=>/*#__PURE__*/t.createElement(U,r({},e,{name:"RouteEditor"})),!0,["control.RouteEditor"]))),z=x(l(d(e=>/*#__PURE__*/t.createElement(U,r({},e,{name:"RoutePanel"})),!0,["control.RoutePanel"]))),G=x(l(d(e=>/*#__PURE__*/t.createElement(U,r({},e,{name:"RulerControl"})),!0,["control.RulerControl"]))),I=x(l(d(e=>/*#__PURE__*/t.createElement(U,r({},e,{name:"SearchControl"})),!0,["control.SearchControl"]))),W=x(l(d(e=>/*#__PURE__*/t.createElement(U,r({},e,{name:"TrafficControl"})),!0,["control.TrafficControl"]))),F=x(l(d(e=>/*#__PURE__*/t.createElement(U,r({},e,{name:"TypeSelector"})),!0,["control.TypeSelector"]))),q=x(l(d(e=>/*#__PURE__*/t.createElement(U,r({},e,{name:"ZoomControl"})),!0,["control.ZoomControl"])));class Y extends t.Component{constructor(){super(),this.state={instance:null},this.instance=null}componentDidMount(){const t=Y.mountObject(this.props.ymaps.Clusterer,this.props);this.instance=t,this.setState({instance:t})}componentDidUpdate(t){null!==this.state.instance&&Y.updateObject(this.instance,t,this.props)}componentWillUnmount(){Y.unmountObject(this.instance,this.props)}render(){/*#__PURE__*/return t.createElement(c.Provider,{value:this.state.instance},this.props.children)}static mountObject(t,e){const{instanceRef:n,parent:o,_events:s}=v(e),r=new t(_(e,"options"));if(Object.keys(s).forEach(t=>j(r,t,s[t])),o.geoObjects&&"function"==typeof o.geoObjects.add)o.geoObjects.add(r);else{if(!o.add||"function"!=typeof o.add)throw new Error("No parent found to mount Clusterer");o.add(r)}return R(null,n,r),r}static updateObject(t,e,n){const{_events:o,instanceRef:s}=v(n),{_events:r,instanceRef:a}=v(e);if(C(n,"options")){const o=_(e,"options"),s=_(n,"options");o!==s&&t.options.set(s)}g(t,r,o),R(a,s,t)}static unmountObject(t,e){const{instanceRef:n,parent:o,_events:s}=v(e);null!==t&&(Object.keys(s).forEach(e=>O(t,e,s[e])),o.geoObjects&&"function"==typeof o.geoObjects.remove?o.geoObjects.remove(t):o.remove&&"function"==typeof o.remove&&o.remove(t),R(n))}}var V=x(l(d(Y,!0,["Clusterer"])));class H extends t.Component{constructor(){super(),this.state={instance:null}}componentDidMount(){const t=H.mountObject(this.props.ymaps.ObjectManager,this.props);this.instance=t,this.setState({instance:t})}componentDidUpdate(t){null!==this.instance&&H.updateObject(this.instance,t,this.props)}componentWillUnmount(){H.unmountObject(this.instance,this.props)}render(){return null}static mountObject(t,e){const{instanceRef:n,parent:o,_events:s}=v(e),r=_(e,"options",{}),a=_(e,"features",{}),i=_(e,"filter",null),c=_(e,"objects",{}),l=_(e,"clusters",{}),p=new t(r);if(p.add(a||[]),p.setFilter(i),p.objects.options.set(c),p.clusters.options.set(l),Object.keys(s).forEach(t=>j(p,t,s[t])),o.geoObjects&&"function"==typeof o.geoObjects.add)o.geoObjects.add(p);else{if(!o.add||"function"!=typeof o.add)throw new Error("No parent found to mount ObjectManager");o.add(p)}return R(null,n,p),p}static updateObject(t,e,n){const{_events:o,instanceRef:s}=v(n),{_events:r,instanceRef:a}=v(e);if(C(n,"options")){const o=_(e,"options"),s=_(n,"options");o!==s&&t.options.set(s)}if(C(n,"objects")){const o=_(e,"objects"),s=_(n,"objects");o!==s&&t.objects.options.set(s)}if(C(n,"clusters")){const o=_(e,"clusters"),s=_(n,"clusters");o!==s&&t.clusters.options.set(s)}if(C(n,"filter")){const o=_(e,"filter"),s=_(n,"filter");o!==s&&t.setFilter(s)}if(C(n,"features")){const o=_(e,"features"),s=_(n,"features");o!==s&&(t.remove(o),t.add(s))}g(t,r,o),R(a,s,t)}static unmountObject(t,e){const{instanceRef:n,parent:o,_events:s}=v(e);null!==t&&(Object.keys(s).forEach(e=>O(t,e,s[e])),o.geoObjects&&"function"==typeof o.geoObjects.remove?o.geoObjects.remove(t):o.remove&&"function"==typeof o.remove&&o.remove(t),R(n))}}var J=x(l(d(H,!0,["ObjectManager"])));class K extends t.Component{constructor(){super(),this.state={instance:null},this.instance=null}componentDidMount(){const{name:t,ymaps:e,dangerZone:n}=this.props,o=K.mountObject(n&&"function"==typeof n.modifyConstructor?n.modifyConstructor(e[t]):e[t],this.props);this.instance=o,this.setState({instance:o})}componentDidUpdate(t){null!==this.instance&&K.updateObject(this.instance,t,this.props)}componentWillUnmount(){K.unmountObject(this.instance,this.props)}render(){return null}static mountObject(t,e){const{instanceRef:n,parent:o,_events:s}=v(e),r=new t(_(e,"geometry"),_(e,"properties"),_(e,"options"));if(Object.keys(s).forEach(t=>j(r,t,s[t])),o&&o.geoObjects&&"function"==typeof o.geoObjects.add)o.geoObjects.add(r);else{if(!o||!o.add||"function"!=typeof o.add)throw new Error(`No parent found to mount ${e.name}`);o.add(r)}return R(null,n,r),r}static updateObject(t,e,n){const{_events:o,instanceRef:s}=v(n),{_events:r,instanceRef:a}=v(e);if(C(n,"geometry")){const o=_(e,"geometry",{}),s=_(n,"geometry",{});Array.isArray(s)&&s!==o?Array.isArray(s[0])&&"number"==typeof s[1]?(t.geometry.setCoordinates(s[0]),t.geometry.setRadius(s[1])):t.geometry.setCoordinates(s):"object"==typeof s&&(s.coordinates!==o.coordinates&&t.geometry.setCoordinates(s.coordinates),s.radius!==o.radius&&t.geometry.setRadius(s.radius))}if(C(n,"properties")){const o=_(e,"properties"),s=_(n,"properties");o!==s&&t.properties.set(s)}if(C(n,"options")){const o=_(e,"options"),s=_(n,"options");o!==s&&t.options.set(s)}g(t,r,o),R(a,s,t)}static unmountObject(t,e){const{instanceRef:n,parent:o,_events:s}=v(e);null!==t&&(Object.keys(s).forEach(e=>O(t,e,s[e])),o.geoObjects&&"function"==typeof o.geoObjects.remove?o.geoObjects.remove(t):o.remove&&"function"==typeof o.remove&&o.remove(t),R(n))}}const Q={modifyConstructor(t){function e(e,n,o){t.call(this,{geometry:e,properties:n},o)}return e.prototype=t.prototype,e}};var X=x(l(d(e=>/*#__PURE__*/t.createElement(K,r({},e,{name:"GeoObject",dangerZone:Q})),!0,["GeoObject"]))),tt=x(l(d(e=>/*#__PURE__*/t.createElement(K,r({},e,{name:"Circle"})),!0,["Circle"]))),et=x(l(d(e=>/*#__PURE__*/t.createElement(K,r({},e,{name:"Placemark"})),!0,["Placemark"]))),nt=x(l(d(e=>/*#__PURE__*/t.createElement(K,r({},e,{name:"Polygon"})),!0,["Polygon"]))),ot=x(l(d(e=>/*#__PURE__*/t.createElement(K,r({},e,{name:"Polyline"})),!0,["Polyline"]))),st=x(l(d(e=>/*#__PURE__*/t.createElement(K,r({},e,{name:"Rectangle"})),!0,["Rectangle"])));export{D as Button,tt as Circle,V as Clusterer,B as FullscreenControl,X as GeoObject,A as GeolocationControl,L as ListBox,$ as ListBoxItem,k as Map,J as ObjectManager,T as Panorama,et as Placemark,nt as Polygon,ot as Polyline,st as Rectangle,N as RouteButton,Z as RouteEditor,z as RoutePanel,G as RulerControl,I as SearchControl,W as TrafficControl,F as TypeSelector,y as YMaps,q as ZoomControl,p as useYMaps,d as withYMaps};
//# sourceMappingURL=react-yandex-maps.esm.js.map
