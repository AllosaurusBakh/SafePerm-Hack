var e=require("react");function t(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var n=/*#__PURE__*/t(e);function o(){return o=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o])}return e},o.apply(this,arguments)}const s=(e,t)=>{const n={};for(const o in e)-1===t.indexOf(o)&&(n[o]=e[o]);return n},r=/*#__PURE__*/n.default.createContext(null),a=/*#__PURE__*/n.default.createContext(null),c=e=>t=>/*#__PURE__*/n.default.createElement(a.Consumer,null,s=>/*#__PURE__*/n.default.createElement(e,o({parent:s},t))),i=(t=[])=>{const[n,o]=e.useState(!1),s=e.useRef(t),a=(()=>{const t=e.useContext(r);if(null===t)throw new Error("Couldn't find Yandex.Maps API in the context. Make sure that hook useYMaps is inside <YMaps /> provider");return t})(),c=a.getApi();return e.useEffect(()=>{a.load().then(()=>Promise.all(s.current.map(a.loadModule))).then(()=>o(!0))},[]),n&&c?c:null},l=()=>{},u=["onLoad","onError","modules","apiLoader"];function p(t,r=!1,a=[]){return c=>{const{width:p,height:d,modules:f=[],onLoad:m=l}=c,h=i(a.concat(f)),y=!r||!!h,b=s(c,u);return e.useEffect(()=>h?m(h):void 0,[h]),y?/*#__PURE__*/n.default.createElement(t,o({ymaps:h},b)):/*#__PURE__*/n.default.createElement("div",{style:{width:p,height:d}})}}const d="undefined"!=typeof window,f={lang:"ru_RU",load:"",ns:"",mode:"release"},m=/^on(?=[A-Z])/;function h(e){return Object.keys(e).reduce((t,n)=>{if(m.test(n)){const o=n.replace(m,"").toLowerCase();t._events[o]=e[n]}else t[n]=e[n];return t},{_events:{}})}function y(e,t,n){"function"==typeof n&&e.events.add(t,n)}function b(e,t,n){"function"==typeof n&&e.events.remove(t,n)}function v(e,t,n){Object.keys(Object.assign({},t,n)).forEach(o=>{t[o]!==n[o]&&(b(e,o,t[o]),y(e,o,n[o]))})}const j=e=>"default"+e.charAt(0).toUpperCase()+e.slice(1);function O(e,t){return void 0!==e[t]||void 0===e[j(t)]}function E(e,t,n){return(O(e,t)?e[t]:e[j(t)])||n}function g(e,t,n=null){if(e!==t){if(e&&("current"in e?e.current=null:"function"==typeof e&&e(null)),!t)return;"current"in t?t.current=n:"function"==typeof t&&t(n)}}function C(e){const{width:t,height:n,style:o,className:s}=e;return void 0!==o||void 0!==s?Object.assign({},o&&{style:o},s&&{className:s}):{style:{width:t,height:n}}}class R extends n.default.Component{constructor(e){super(e),this.state={error:null,errorInfo:null}}componentDidCatch(e,t){const{onError:n=(()=>{})}=this.props;n(e),this.setState({error:e,errorInfo:t})}render(){return this.state.error?null:this.props.children}}const _=e=>({onError:t,...o})=>/*#__PURE__*/n.default.createElement(R,{onError:t},/*#__PURE__*/n.default.createElement(e,o));class x extends n.default.Component{constructor(){super(),this.instance=null,this.state={instance:null},this._parentElement=null,this._getRef=e=>{this._parentElement=e}}componentDidMount(){this.instance=x.mountObject(this._parentElement,this.props.ymaps.Map,this.props),this.setState({instance:this.instance})}componentDidUpdate(e){null!==this.instance&&x.updateObject(this.instance,e,this.props)}componentWillUnmount(){x.unmountObject(this.instance,this.props)}render(){const e=C(this.props),t=h(this.props),r=s(t,["_events","state","defaultState","options","defaultOptions","instanceRef","ymaps","children","width","height","style","className"]);/*#__PURE__*/return n.default.createElement(a.Provider,{value:this.state.instance},/*#__PURE__*/n.default.createElement("div",o({ref:this._getRef},e,r),this.props.children))}static mountObject(e,t,n){const{instanceRef:o,_events:s}=h(n),r=new t(e,E(n,"state"),E(n,"options"));return Object.keys(s).forEach(e=>y(r,e,s[e])),g(null,o,r),r}static updateObject(e,t,n){const{_events:o,instanceRef:s}=h(n),{_events:r,instanceRef:a}=h(t);if(O(n,"state")){const o=E(t,"state",{}),s=E(n,"state",{});o.type!==s.type&&e.setType(s.type),o.behaviors!==s.behaviors&&(o.behaviors&&e.behaviors.disable(o.behaviors),s.behaviors&&e.behaviors.enable(s.behaviors)),s.zoom&&o.zoom!==s.zoom&&e.setZoom(s.zoom),s.center&&o.center!==s.center&&e.setCenter(s.center),s.bounds&&o.bounds!==s.bounds&&e.setBounds(s.bounds)}if(O(n,"options")){const o=E(t,"options"),s=E(n,"options",{});o!==s&&e.options.set(s)}E(t,"width")===E(n,"width")&&E(t,"height")===E(n,"height")||e.container.fitToViewport(),v(e,r,o),g(a,s,e)}static unmountObject(e,t){const{instanceRef:n,_events:o}=h(t);null!==e&&(Object.keys(o).forEach(t=>b(e,t,o[t])),e.destroy(),g(n))}}const w=_(p(x,!0,["Map"]));w.defaultProps={width:320,height:240};class P extends n.default.Component{constructor(){super(),this.state={instance:null},this._parentElement=null,this._getRef=e=>{this._parentElement=e}}componentDidMount(){this._mounted=!0,this.props.ymaps.panorama.isSupported()&&P.mountObject(this._parentElement,this.props.ymaps.panorama,this.props).then(e=>this._mounted&&this.setState({instance:e}))}componentDidUpdate(e){null!==this.state.instance&&P.updateObject(this.state.instance,e,this.props)}componentWillUnmount(){this._mounted=!1,P.unmountObject(this.state.instance,this.props)}render(){const e=C(this.props);/*#__PURE__*/return n.default.createElement("div",o({ref:this._getRef},e))}static mountObject(e,t,n){const{instanceRef:o,_events:s}=h(n),r=E(n,"point"),a=E(n,"locateOptions"),c=E(n,"options");return new Promise((n,i)=>{t.locate(r,a).done(r=>{if(r.length>0){const a=new t.Player(e,r[0],c);g(null,o,a),Object.keys(s).forEach(e=>y(a,e,s[e])),n(a)}},i)})}static updateObject(e,t,n){const{_events:o,instanceRef:s}=h(n),{_events:r,instanceRef:a}=h(t);if(O(n,"options")){const o=E(t,"options"),s=E(n,"options");o!==s&&e.options.set(s)}if(O(n,"point")){const o=E(n,"point"),s=E(t,"point"),r=E(n,"locateOptions");o!==s&&e.moveTo(o,r)}v(e,r,o),g(a,s,e)}static unmountObject(e,t){const{instanceRef:n,_events:o}=h(t);null!==e&&(Object.keys(o).forEach(t=>b(e,t,o[t])),g(n))}}const M=_(p(P,!0,["panorama.isSupported","panorama.locate","panorama.createPlayer","panorama.Player"]));M.defaultProps={width:320,height:240};class k extends n.default.Component{constructor(){super(),this.state={instance:null},this.instance=null}componentDidMount(){const e=k.mountControl(this.props.ymaps.control[this.props.name],this.props);this.instance=e,this.setState({instance:e})}componentDidUpdate(e){null!==this.instance&&k.updateControl(this.instance,e,this.props)}componentWillUnmount(){k.unmountControl(this.instance,this.props)}render(){/*#__PURE__*/return n.default.createElement(a.Provider,{value:this.state.instance},this.props.children)}static mountControl(e,t){const{instanceRef:n,parent:o,lazy:s,_events:r}=h(t),a=new e({data:E(t,"data"),options:E(t,"options"),state:E(t,"state"),mapTypes:E(t,"mapTypes"),lazy:s});if(Object.keys(r).forEach(e=>y(a,e,r[e])),o&&o.controls&&"function"==typeof o.controls.add)o.controls.add(a);else{if(!o||!o.add||"function"!=typeof o.add)throw new Error(`No parent found to mount ${t.name}`);o.add(a)}return g(null,n,a),a}static updateControl(e,t,n){const{_events:o,instanceRef:s}=h(n),{_events:r,instanceRef:a}=h(t);if(O(n,"options")){const o=E(t,"options"),s=E(n,"options");o!==s&&e.options.set(s)}if(O(n,"data")){const o=E(t,"data"),s=E(n,"data");o!==s&&e.data.set(s)}if(O(n,"state")){const o=E(t,"state"),s=E(n,"state");o!==s&&e.state.set(s)}if(O(n,"mapTypes")){const o=E(t,"mapTypes"),s=E(n,"mapTypes");o!==s&&(e.removeAllMapTypes(),s.forEach(t=>e.addMapType(t)))}v(e,r,o),g(a,s,e)}static unmountControl(e,t){const{instanceRef:n,parent:o,_events:s}=h(t);null!==e&&(Object.keys(s).forEach(t=>b(e,t,s[t])),o.controls&&"function"==typeof o.controls.remove?o.controls.remove(e):o.remove&&"function"==typeof o.remove&&o.remove(e),g(n))}}var S=_(c(p(e=>/*#__PURE__*/n.default.createElement(k,o({},e,{name:"Button"})),!0,["control.Button"]))),T=_(c(p(e=>/*#__PURE__*/n.default.createElement(k,o({},e,{name:"FullscreenControl"})),!0,["control.FullscreenControl"]))),U=_(c(p(e=>/*#__PURE__*/n.default.createElement(k,o({},e,{name:"GeolocationControl"})),!0,["control.GeolocationControl"]))),D=_(c(p(e=>/*#__PURE__*/n.default.createElement(k,o({},e,{name:"ListBox"})),!0,["control.ListBox"]))),B=_(c(p(e=>/*#__PURE__*/n.default.createElement(k,o({},e,{name:"ListBoxItem"})),!0,["control.ListBoxItem"]))),A=_(c(p(e=>/*#__PURE__*/n.default.createElement(k,o({},e,{name:"RouteButton"})),!0,["control.RouteButton"]))),L=_(c(p(e=>/*#__PURE__*/n.default.createElement(k,o({},e,{name:"RouteEditor"})),!0,["control.RouteEditor"]))),$=_(c(p(e=>/*#__PURE__*/n.default.createElement(k,o({},e,{name:"RoutePanel"})),!0,["control.RoutePanel"]))),N=_(c(p(e=>/*#__PURE__*/n.default.createElement(k,o({},e,{name:"RulerControl"})),!0,["control.RulerControl"]))),Z=_(c(p(e=>/*#__PURE__*/n.default.createElement(k,o({},e,{name:"SearchControl"})),!0,["control.SearchControl"]))),z=_(c(p(e=>/*#__PURE__*/n.default.createElement(k,o({},e,{name:"TrafficControl"})),!0,["control.TrafficControl"]))),G=_(c(p(e=>/*#__PURE__*/n.default.createElement(k,o({},e,{name:"TypeSelector"})),!0,["control.TypeSelector"]))),I=_(c(p(e=>/*#__PURE__*/n.default.createElement(k,o({},e,{name:"ZoomControl"})),!0,["control.ZoomControl"])));class W extends n.default.Component{constructor(){super(),this.state={instance:null},this.instance=null}componentDidMount(){const e=W.mountObject(this.props.ymaps.Clusterer,this.props);this.instance=e,this.setState({instance:e})}componentDidUpdate(e){null!==this.state.instance&&W.updateObject(this.instance,e,this.props)}componentWillUnmount(){W.unmountObject(this.instance,this.props)}render(){/*#__PURE__*/return n.default.createElement(a.Provider,{value:this.state.instance},this.props.children)}static mountObject(e,t){const{instanceRef:n,parent:o,_events:s}=h(t),r=new e(E(t,"options"));if(Object.keys(s).forEach(e=>y(r,e,s[e])),o.geoObjects&&"function"==typeof o.geoObjects.add)o.geoObjects.add(r);else{if(!o.add||"function"!=typeof o.add)throw new Error("No parent found to mount Clusterer");o.add(r)}return g(null,n,r),r}static updateObject(e,t,n){const{_events:o,instanceRef:s}=h(n),{_events:r,instanceRef:a}=h(t);if(O(n,"options")){const o=E(t,"options"),s=E(n,"options");o!==s&&e.options.set(s)}v(e,r,o),g(a,s,e)}static unmountObject(e,t){const{instanceRef:n,parent:o,_events:s}=h(t);null!==e&&(Object.keys(s).forEach(t=>b(e,t,s[t])),o.geoObjects&&"function"==typeof o.geoObjects.remove?o.geoObjects.remove(e):o.remove&&"function"==typeof o.remove&&o.remove(e),g(n))}}var Y=_(c(p(W,!0,["Clusterer"])));class q extends n.default.Component{constructor(){super(),this.state={instance:null}}componentDidMount(){const e=q.mountObject(this.props.ymaps.ObjectManager,this.props);this.instance=e,this.setState({instance:e})}componentDidUpdate(e){null!==this.instance&&q.updateObject(this.instance,e,this.props)}componentWillUnmount(){q.unmountObject(this.instance,this.props)}render(){return null}static mountObject(e,t){const{instanceRef:n,parent:o,_events:s}=h(t),r=E(t,"options",{}),a=E(t,"features",{}),c=E(t,"filter",null),i=E(t,"objects",{}),l=E(t,"clusters",{}),u=new e(r);if(u.add(a||[]),u.setFilter(c),u.objects.options.set(i),u.clusters.options.set(l),Object.keys(s).forEach(e=>y(u,e,s[e])),o.geoObjects&&"function"==typeof o.geoObjects.add)o.geoObjects.add(u);else{if(!o.add||"function"!=typeof o.add)throw new Error("No parent found to mount ObjectManager");o.add(u)}return g(null,n,u),u}static updateObject(e,t,n){const{_events:o,instanceRef:s}=h(n),{_events:r,instanceRef:a}=h(t);if(O(n,"options")){const o=E(t,"options"),s=E(n,"options");o!==s&&e.options.set(s)}if(O(n,"objects")){const o=E(t,"objects"),s=E(n,"objects");o!==s&&e.objects.options.set(s)}if(O(n,"clusters")){const o=E(t,"clusters"),s=E(n,"clusters");o!==s&&e.clusters.options.set(s)}if(O(n,"filter")){const o=E(t,"filter"),s=E(n,"filter");o!==s&&e.setFilter(s)}if(O(n,"features")){const o=E(t,"features"),s=E(n,"features");o!==s&&(e.remove(o),e.add(s))}v(e,r,o),g(a,s,e)}static unmountObject(e,t){const{instanceRef:n,parent:o,_events:s}=h(t);null!==e&&(Object.keys(s).forEach(t=>b(e,t,s[t])),o.geoObjects&&"function"==typeof o.geoObjects.remove?o.geoObjects.remove(e):o.remove&&"function"==typeof o.remove&&o.remove(e),g(n))}}var F=_(c(p(q,!0,["ObjectManager"])));class V extends n.default.Component{constructor(){super(),this.state={instance:null},this.instance=null}componentDidMount(){const{name:e,ymaps:t,dangerZone:n}=this.props,o=V.mountObject(n&&"function"==typeof n.modifyConstructor?n.modifyConstructor(t[e]):t[e],this.props);this.instance=o,this.setState({instance:o})}componentDidUpdate(e){null!==this.instance&&V.updateObject(this.instance,e,this.props)}componentWillUnmount(){V.unmountObject(this.instance,this.props)}render(){return null}static mountObject(e,t){const{instanceRef:n,parent:o,_events:s}=h(t),r=new e(E(t,"geometry"),E(t,"properties"),E(t,"options"));if(Object.keys(s).forEach(e=>y(r,e,s[e])),o&&o.geoObjects&&"function"==typeof o.geoObjects.add)o.geoObjects.add(r);else{if(!o||!o.add||"function"!=typeof o.add)throw new Error(`No parent found to mount ${t.name}`);o.add(r)}return g(null,n,r),r}static updateObject(e,t,n){const{_events:o,instanceRef:s}=h(n),{_events:r,instanceRef:a}=h(t);if(O(n,"geometry")){const o=E(t,"geometry",{}),s=E(n,"geometry",{});Array.isArray(s)&&s!==o?Array.isArray(s[0])&&"number"==typeof s[1]?(e.geometry.setCoordinates(s[0]),e.geometry.setRadius(s[1])):e.geometry.setCoordinates(s):"object"==typeof s&&(s.coordinates!==o.coordinates&&e.geometry.setCoordinates(s.coordinates),s.radius!==o.radius&&e.geometry.setRadius(s.radius))}if(O(n,"properties")){const o=E(t,"properties"),s=E(n,"properties");o!==s&&e.properties.set(s)}if(O(n,"options")){const o=E(t,"options"),s=E(n,"options");o!==s&&e.options.set(s)}v(e,r,o),g(a,s,e)}static unmountObject(e,t){const{instanceRef:n,parent:o,_events:s}=h(t);null!==e&&(Object.keys(s).forEach(t=>b(e,t,s[t])),o.geoObjects&&"function"==typeof o.geoObjects.remove?o.geoObjects.remove(e):o.remove&&"function"==typeof o.remove&&o.remove(e),g(n))}}const H={modifyConstructor(e){function t(t,n,o){e.call(this,{geometry:t,properties:n},o)}return t.prototype=e.prototype,t}};var J=_(c(p(e=>/*#__PURE__*/n.default.createElement(V,o({},e,{name:"GeoObject",dangerZone:H})),!0,["GeoObject"]))),K=_(c(p(e=>/*#__PURE__*/n.default.createElement(V,o({},e,{name:"Circle"})),!0,["Circle"]))),Q=_(c(p(e=>/*#__PURE__*/n.default.createElement(V,o({},e,{name:"Placemark"})),!0,["Placemark"]))),X=_(c(p(e=>/*#__PURE__*/n.default.createElement(V,o({},e,{name:"Polygon"})),!0,["Polygon"]))),ee=_(c(p(e=>/*#__PURE__*/n.default.createElement(V,o({},e,{name:"Polyline"})),!0,["Polyline"]))),te=_(c(p(e=>/*#__PURE__*/n.default.createElement(V,o({},e,{name:"Rectangle"})),!0,["Rectangle"])));exports.Button=S,exports.Circle=K,exports.Clusterer=Y,exports.FullscreenControl=T,exports.GeoObject=J,exports.GeolocationControl=U,exports.ListBox=D,exports.ListBoxItem=B,exports.Map=w,exports.ObjectManager=F,exports.Panorama=M,exports.Placemark=Q,exports.Polygon=X,exports.Polyline=ee,exports.Rectangle=te,exports.RouteButton=A,exports.RouteEditor=L,exports.RoutePanel=$,exports.RulerControl=N,exports.SearchControl=Z,exports.TrafficControl=z,exports.TypeSelector=G,exports.YMaps=t=>{const{version:o="2.1",enterprise:s=!1,query:a={lang:"ru_RU",load:"",ns:""},preload:c=!1,children:i}=t,l=e.useRef((e=>{const{query:t=f}=e,n=Date.now().toString(32),o=t.ns||"",s="__yandex-maps-api-onload__$$"+n,r="__yandex-maps-api-onerror__$$"+n,a=d?window:{},c={};let i;const l=()=>o?a[o]:i,u=()=>{delete a[s],delete a[r]};return{load:()=>{if(l())return Promise.resolve(i);if(c[o])return c[o];const n={onload:s,onerror:r,...f,...t},p=Object.keys(n).map(e=>`${e}=${n[e]}`).join("&"),d=[`https://${e.enterprise?"enterprise.":""}api-maps.yandex.ru`,e.version,"?"+p].join("/");return c[o]=new Promise((e,t)=>{a[s]=t=>{u(),t.ready(()=>{i=t,e(t)})},a[r]=e=>{u(),t(e)},(e=>new Promise((t,n)=>{const o=document.createElement("script");o.type="text/javascript",o.onload=t,o.onerror=n,o.src=e,o.async=!0,document.head.appendChild(o)}))(d).catch(a[r])}),c[o]},getApi:l,loadModule:e=>new Promise((t,n)=>{i.modules.require(e).done(n=>{n.forEach(t=>{((e,t,n,o=!1)=>{const s="string"==typeof t?t.split("."):t.slice();let r,a=e;for(;s.length>1;)r=s.shift(),a[r]||(a[r]={}),a=a[r];const c=s[0];a[c]=!0===o&&a[c]||n})(i,e,t,!0)}),t(i)},n)})}})({version:o,enterprise:s,query:a,preload:c}));return e.useEffect(()=>{c&&l.current.load()},[l.current]),/*#__PURE__*/n.default.createElement(r.Provider,{value:l.current},i)},exports.ZoomControl=I,exports.useYMaps=i,exports.withYMaps=p;
//# sourceMappingURL=react-yandex-maps.js.map
