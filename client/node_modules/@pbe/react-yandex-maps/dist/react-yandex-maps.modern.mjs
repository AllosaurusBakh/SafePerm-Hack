import t,{useContext as e,useState as n,useRef as o,useEffect as s}from"react";function r(){return r=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(t[o]=n[o])}return t},r.apply(this,arguments)}const a=(t,e)=>{const n={};for(const o in t)-1===e.indexOf(o)&&(n[o]=t[o]);return n},i=/*#__PURE__*/t.createContext(null),c=/*#__PURE__*/t.createContext(null),l=e=>n=>/*#__PURE__*/t.createElement(c.Consumer,null,o=>/*#__PURE__*/t.createElement(e,r({parent:o},n))),p=(t=[])=>{const[r,a]=n(!1),c=o(t),l=(()=>{const t=e(i);if(null===t)throw new Error("Couldn't find Yandex.Maps API in the context. Make sure that hook useYMaps is inside <YMaps /> provider");return t})(),p=l.getApi();return s(()=>{l.load().then(()=>Promise.all(c.current.map(l.loadModule))).then(()=>a(!0))},[]),r&&p?p:null},u=()=>{},m=["onLoad","onError","modules","apiLoader"];function d(e,n=!1,o=[]){return i=>{const{width:c,height:l,modules:d=[],onLoad:f=u}=i,h=p(o.concat(d)),y=!n||!!h,b=a(i,m);return s(()=>h?f(h):void 0,[h]),y?/*#__PURE__*/t.createElement(e,r({ymaps:h},b)):/*#__PURE__*/t.createElement("div",{style:{width:c,height:l}})}}const f="undefined"!=typeof window,h={lang:"ru_RU",load:"",ns:"",mode:"release"},y=e=>{const{version:n="2.1",enterprise:a=!1,query:c={lang:"ru_RU",load:"",ns:""},preload:l=!1,children:p}=e,u=o((t=>{const{query:e=h}=t,n=Date.now().toString(32),o=e.ns||"",s="__yandex-maps-api-onload__$$"+n,a="__yandex-maps-api-onerror__$$"+n,i=f?window:{},c={};let l;const p=()=>o?i[o]:l,u=()=>{delete i[s],delete i[a]};return{load:()=>{if(p())return Promise.resolve(l);if(c[o])return c[o];const n=r({onload:s,onerror:a},h,e),m=Object.keys(n).map(t=>`${t}=${n[t]}`).join("&"),d=[`https://${t.enterprise?"enterprise.":""}api-maps.yandex.ru`,t.version,"?"+m].join("/");return c[o]=new Promise((t,e)=>{i[s]=e=>{u(),e.ready(()=>{l=e,t(e)})},i[a]=t=>{u(),e(t)},(t=>new Promise((e,n)=>{const o=document.createElement("script");o.type="text/javascript",o.onload=e,o.onerror=n,o.src=t,o.async=!0,document.head.appendChild(o)}))(d).catch(i[a])}),c[o]},getApi:p,loadModule:t=>new Promise((e,n)=>{l.modules.require(t).done(n=>{n.forEach(e=>{((t,e,n,o=!1)=>{const s="string"==typeof e?e.split("."):e.slice();let r,a=t;for(;s.length>1;)r=s.shift(),a[r]||(a[r]={}),a=a[r];const i=s[0];a[i]=!0===o&&a[i]||n})(l,t,e,!0)}),e(l)},n)})}})({version:n,enterprise:a,query:c,preload:l}));return s(()=>{l&&u.current.load()},[u.current]),/*#__PURE__*/t.createElement(i.Provider,{value:u.current},p)},b=/^on(?=[A-Z])/;function v(t){return Object.keys(t).reduce((e,n)=>{if(b.test(n)){const o=n.replace(b,"").toLowerCase();e._events[o]=t[n]}else e[n]=t[n];return e},{_events:{}})}function j(t,e,n){"function"==typeof n&&t.events.add(e,n)}function O(t,e,n){"function"==typeof n&&t.events.remove(e,n)}function g(t,e,n){Object.keys(Object.assign({},e,n)).forEach(o=>{e[o]!==n[o]&&(O(t,o,e[o]),j(t,o,n[o]))})}const E=t=>"default"+t.charAt(0).toUpperCase()+t.slice(1);function C(t,e){return void 0!==t[e]||void 0===t[E(e)]}function _(t,e,n){return(C(t,e)?t[e]:t[E(e)])||n}function R(t,e,n=null){if(t!==e){if(t&&("current"in t?t.current=null:"function"==typeof t&&t(null)),!e)return;"current"in e?e.current=n:"function"==typeof e&&e(n)}}function w(t){const{width:e,height:n,style:o,className:s}=t;return void 0!==o||void 0!==s?Object.assign({},o&&{style:o},s&&{className:s}):{style:{width:e,height:n}}}const P=["onError"];class x extends t.Component{constructor(t){super(t),this.state={error:null,errorInfo:null}}componentDidCatch(t,e){const{onError:n=(()=>{})}=this.props;n(t),this.setState({error:t,errorInfo:e})}render(){return this.state.error?null:this.props.children}}const M=e=>n=>{let{onError:o}=n,s=function(t,e){if(null==t)return{};var n,o,s={},r=Object.keys(t);for(o=0;o<r.length;o++)e.indexOf(n=r[o])>=0||(s[n]=t[n]);return s}(n,P);/*#__PURE__*/return t.createElement(x,{onError:o},/*#__PURE__*/t.createElement(e,s))};class k extends t.Component{constructor(){super(),this.instance=null,this.state={instance:null},this._parentElement=null,this._getRef=t=>{this._parentElement=t}}componentDidMount(){this.instance=k.mountObject(this._parentElement,this.props.ymaps.Map,this.props),this.setState({instance:this.instance})}componentDidUpdate(t){null!==this.instance&&k.updateObject(this.instance,t,this.props)}componentWillUnmount(){k.unmountObject(this.instance,this.props)}render(){const e=w(this.props),n=v(this.props),o=a(n,["_events","state","defaultState","options","defaultOptions","instanceRef","ymaps","children","width","height","style","className"]);/*#__PURE__*/return t.createElement(c.Provider,{value:this.state.instance},/*#__PURE__*/t.createElement("div",r({ref:this._getRef},e,o),this.props.children))}static mountObject(t,e,n){const{instanceRef:o,_events:s}=v(n),r=new e(t,_(n,"state"),_(n,"options"));return Object.keys(s).forEach(t=>j(r,t,s[t])),R(null,o,r),r}static updateObject(t,e,n){const{_events:o,instanceRef:s}=v(n),{_events:r,instanceRef:a}=v(e);if(C(n,"state")){const o=_(e,"state",{}),s=_(n,"state",{});o.type!==s.type&&t.setType(s.type),o.behaviors!==s.behaviors&&(o.behaviors&&t.behaviors.disable(o.behaviors),s.behaviors&&t.behaviors.enable(s.behaviors)),s.zoom&&o.zoom!==s.zoom&&t.setZoom(s.zoom),s.center&&o.center!==s.center&&t.setCenter(s.center),s.bounds&&o.bounds!==s.bounds&&t.setBounds(s.bounds)}if(C(n,"options")){const o=_(e,"options"),s=_(n,"options",{});o!==s&&t.options.set(s)}_(e,"width")===_(n,"width")&&_(e,"height")===_(n,"height")||t.container.fitToViewport(),g(t,r,o),R(a,s,t)}static unmountObject(t,e){const{instanceRef:n,_events:o}=v(e);null!==t&&(Object.keys(o).forEach(e=>O(t,e,o[e])),t.destroy(),R(n))}}const S=M(d(k,!0,["Map"]));S.defaultProps={width:320,height:240};class T extends t.Component{constructor(){super(),this.state={instance:null},this._parentElement=null,this._getRef=t=>{this._parentElement=t}}componentDidMount(){this._mounted=!0,this.props.ymaps.panorama.isSupported()&&T.mountObject(this._parentElement,this.props.ymaps.panorama,this.props).then(t=>this._mounted&&this.setState({instance:t}))}componentDidUpdate(t){null!==this.state.instance&&T.updateObject(this.state.instance,t,this.props)}componentWillUnmount(){this._mounted=!1,T.unmountObject(this.state.instance,this.props)}render(){const e=w(this.props);/*#__PURE__*/return t.createElement("div",r({ref:this._getRef},e))}static mountObject(t,e,n){const{instanceRef:o,_events:s}=v(n),r=_(n,"point"),a=_(n,"locateOptions"),i=_(n,"options");return new Promise((n,c)=>{e.locate(r,a).done(r=>{if(r.length>0){const a=new e.Player(t,r[0],i);R(null,o,a),Object.keys(s).forEach(t=>j(a,t,s[t])),n(a)}},c)})}static updateObject(t,e,n){const{_events:o,instanceRef:s}=v(n),{_events:r,instanceRef:a}=v(e);if(C(n,"options")){const o=_(e,"options"),s=_(n,"options");o!==s&&t.options.set(s)}if(C(n,"point")){const o=_(n,"point"),s=_(e,"point"),r=_(n,"locateOptions");o!==s&&t.moveTo(o,r)}g(t,r,o),R(a,s,t)}static unmountObject(t,e){const{instanceRef:n,_events:o}=v(e);null!==t&&(Object.keys(o).forEach(e=>O(t,e,o[e])),R(n))}}const U=M(d(T,!0,["panorama.isSupported","panorama.locate","panorama.createPlayer","panorama.Player"]));U.defaultProps={width:320,height:240};class D extends t.Component{constructor(){super(),this.state={instance:null},this.instance=null}componentDidMount(){const t=D.mountControl(this.props.ymaps.control[this.props.name],this.props);this.instance=t,this.setState({instance:t})}componentDidUpdate(t){null!==this.instance&&D.updateControl(this.instance,t,this.props)}componentWillUnmount(){D.unmountControl(this.instance,this.props)}render(){/*#__PURE__*/return t.createElement(c.Provider,{value:this.state.instance},this.props.children)}static mountControl(t,e){const{instanceRef:n,parent:o,lazy:s,_events:r}=v(e),a=new t({data:_(e,"data"),options:_(e,"options"),state:_(e,"state"),mapTypes:_(e,"mapTypes"),lazy:s});if(Object.keys(r).forEach(t=>j(a,t,r[t])),o&&o.controls&&"function"==typeof o.controls.add)o.controls.add(a);else{if(!o||!o.add||"function"!=typeof o.add)throw new Error(`No parent found to mount ${e.name}`);o.add(a)}return R(null,n,a),a}static updateControl(t,e,n){const{_events:o,instanceRef:s}=v(n),{_events:r,instanceRef:a}=v(e);if(C(n,"options")){const o=_(e,"options"),s=_(n,"options");o!==s&&t.options.set(s)}if(C(n,"data")){const o=_(e,"data"),s=_(n,"data");o!==s&&t.data.set(s)}if(C(n,"state")){const o=_(e,"state"),s=_(n,"state");o!==s&&t.state.set(s)}if(C(n,"mapTypes")){const o=_(e,"mapTypes"),s=_(n,"mapTypes");o!==s&&(t.removeAllMapTypes(),s.forEach(e=>t.addMapType(e)))}g(t,r,o),R(a,s,t)}static unmountControl(t,e){const{instanceRef:n,parent:o,_events:s}=v(e);null!==t&&(Object.keys(s).forEach(e=>O(t,e,s[e])),o.controls&&"function"==typeof o.controls.remove?o.controls.remove(t):o.remove&&"function"==typeof o.remove&&o.remove(t),R(n))}}var B=M(l(d(e=>/*#__PURE__*/t.createElement(D,r({},e,{name:"Button"})),!0,["control.Button"]))),A=M(l(d(e=>/*#__PURE__*/t.createElement(D,r({},e,{name:"FullscreenControl"})),!0,["control.FullscreenControl"]))),L=M(l(d(e=>/*#__PURE__*/t.createElement(D,r({},e,{name:"GeolocationControl"})),!0,["control.GeolocationControl"]))),$=M(l(d(e=>/*#__PURE__*/t.createElement(D,r({},e,{name:"ListBox"})),!0,["control.ListBox"]))),N=M(l(d(e=>/*#__PURE__*/t.createElement(D,r({},e,{name:"ListBoxItem"})),!0,["control.ListBoxItem"]))),Z=M(l(d(e=>/*#__PURE__*/t.createElement(D,r({},e,{name:"RouteButton"})),!0,["control.RouteButton"]))),z=M(l(d(e=>/*#__PURE__*/t.createElement(D,r({},e,{name:"RouteEditor"})),!0,["control.RouteEditor"]))),G=M(l(d(e=>/*#__PURE__*/t.createElement(D,r({},e,{name:"RoutePanel"})),!0,["control.RoutePanel"]))),I=M(l(d(e=>/*#__PURE__*/t.createElement(D,r({},e,{name:"RulerControl"})),!0,["control.RulerControl"]))),W=M(l(d(e=>/*#__PURE__*/t.createElement(D,r({},e,{name:"SearchControl"})),!0,["control.SearchControl"]))),F=M(l(d(e=>/*#__PURE__*/t.createElement(D,r({},e,{name:"TrafficControl"})),!0,["control.TrafficControl"]))),q=M(l(d(e=>/*#__PURE__*/t.createElement(D,r({},e,{name:"TypeSelector"})),!0,["control.TypeSelector"]))),Y=M(l(d(e=>/*#__PURE__*/t.createElement(D,r({},e,{name:"ZoomControl"})),!0,["control.ZoomControl"])));class V extends t.Component{constructor(){super(),this.state={instance:null},this.instance=null}componentDidMount(){const t=V.mountObject(this.props.ymaps.Clusterer,this.props);this.instance=t,this.setState({instance:t})}componentDidUpdate(t){null!==this.state.instance&&V.updateObject(this.instance,t,this.props)}componentWillUnmount(){V.unmountObject(this.instance,this.props)}render(){/*#__PURE__*/return t.createElement(c.Provider,{value:this.state.instance},this.props.children)}static mountObject(t,e){const{instanceRef:n,parent:o,_events:s}=v(e),r=new t(_(e,"options"));if(Object.keys(s).forEach(t=>j(r,t,s[t])),o.geoObjects&&"function"==typeof o.geoObjects.add)o.geoObjects.add(r);else{if(!o.add||"function"!=typeof o.add)throw new Error("No parent found to mount Clusterer");o.add(r)}return R(null,n,r),r}static updateObject(t,e,n){const{_events:o,instanceRef:s}=v(n),{_events:r,instanceRef:a}=v(e);if(C(n,"options")){const o=_(e,"options"),s=_(n,"options");o!==s&&t.options.set(s)}g(t,r,o),R(a,s,t)}static unmountObject(t,e){const{instanceRef:n,parent:o,_events:s}=v(e);null!==t&&(Object.keys(s).forEach(e=>O(t,e,s[e])),o.geoObjects&&"function"==typeof o.geoObjects.remove?o.geoObjects.remove(t):o.remove&&"function"==typeof o.remove&&o.remove(t),R(n))}}var H=M(l(d(V,!0,["Clusterer"])));class J extends t.Component{constructor(){super(),this.state={instance:null}}componentDidMount(){const t=J.mountObject(this.props.ymaps.ObjectManager,this.props);this.instance=t,this.setState({instance:t})}componentDidUpdate(t){null!==this.instance&&J.updateObject(this.instance,t,this.props)}componentWillUnmount(){J.unmountObject(this.instance,this.props)}render(){return null}static mountObject(t,e){const{instanceRef:n,parent:o,_events:s}=v(e),r=_(e,"options",{}),a=_(e,"features",{}),i=_(e,"filter",null),c=_(e,"objects",{}),l=_(e,"clusters",{}),p=new t(r);if(p.add(a||[]),p.setFilter(i),p.objects.options.set(c),p.clusters.options.set(l),Object.keys(s).forEach(t=>j(p,t,s[t])),o.geoObjects&&"function"==typeof o.geoObjects.add)o.geoObjects.add(p);else{if(!o.add||"function"!=typeof o.add)throw new Error("No parent found to mount ObjectManager");o.add(p)}return R(null,n,p),p}static updateObject(t,e,n){const{_events:o,instanceRef:s}=v(n),{_events:r,instanceRef:a}=v(e);if(C(n,"options")){const o=_(e,"options"),s=_(n,"options");o!==s&&t.options.set(s)}if(C(n,"objects")){const o=_(e,"objects"),s=_(n,"objects");o!==s&&t.objects.options.set(s)}if(C(n,"clusters")){const o=_(e,"clusters"),s=_(n,"clusters");o!==s&&t.clusters.options.set(s)}if(C(n,"filter")){const o=_(e,"filter"),s=_(n,"filter");o!==s&&t.setFilter(s)}if(C(n,"features")){const o=_(e,"features"),s=_(n,"features");o!==s&&(t.remove(o),t.add(s))}g(t,r,o),R(a,s,t)}static unmountObject(t,e){const{instanceRef:n,parent:o,_events:s}=v(e);null!==t&&(Object.keys(s).forEach(e=>O(t,e,s[e])),o.geoObjects&&"function"==typeof o.geoObjects.remove?o.geoObjects.remove(t):o.remove&&"function"==typeof o.remove&&o.remove(t),R(n))}}var K=M(l(d(J,!0,["ObjectManager"])));class Q extends t.Component{constructor(){super(),this.state={instance:null},this.instance=null}componentDidMount(){const{name:t,ymaps:e,dangerZone:n}=this.props,o=Q.mountObject(n&&"function"==typeof n.modifyConstructor?n.modifyConstructor(e[t]):e[t],this.props);this.instance=o,this.setState({instance:o})}componentDidUpdate(t){null!==this.instance&&Q.updateObject(this.instance,t,this.props)}componentWillUnmount(){Q.unmountObject(this.instance,this.props)}render(){return null}static mountObject(t,e){const{instanceRef:n,parent:o,_events:s}=v(e),r=new t(_(e,"geometry"),_(e,"properties"),_(e,"options"));if(Object.keys(s).forEach(t=>j(r,t,s[t])),o&&o.geoObjects&&"function"==typeof o.geoObjects.add)o.geoObjects.add(r);else{if(!o||!o.add||"function"!=typeof o.add)throw new Error(`No parent found to mount ${e.name}`);o.add(r)}return R(null,n,r),r}static updateObject(t,e,n){const{_events:o,instanceRef:s}=v(n),{_events:r,instanceRef:a}=v(e);if(C(n,"geometry")){const o=_(e,"geometry",{}),s=_(n,"geometry",{});Array.isArray(s)&&s!==o?Array.isArray(s[0])&&"number"==typeof s[1]?(t.geometry.setCoordinates(s[0]),t.geometry.setRadius(s[1])):t.geometry.setCoordinates(s):"object"==typeof s&&(s.coordinates!==o.coordinates&&t.geometry.setCoordinates(s.coordinates),s.radius!==o.radius&&t.geometry.setRadius(s.radius))}if(C(n,"properties")){const o=_(e,"properties"),s=_(n,"properties");o!==s&&t.properties.set(s)}if(C(n,"options")){const o=_(e,"options"),s=_(n,"options");o!==s&&t.options.set(s)}g(t,r,o),R(a,s,t)}static unmountObject(t,e){const{instanceRef:n,parent:o,_events:s}=v(e);null!==t&&(Object.keys(s).forEach(e=>O(t,e,s[e])),o.geoObjects&&"function"==typeof o.geoObjects.remove?o.geoObjects.remove(t):o.remove&&"function"==typeof o.remove&&o.remove(t),R(n))}}const X={modifyConstructor(t){function e(e,n,o){t.call(this,{geometry:e,properties:n},o)}return e.prototype=t.prototype,e}};var tt=M(l(d(e=>/*#__PURE__*/t.createElement(Q,r({},e,{name:"GeoObject",dangerZone:X})),!0,["GeoObject"]))),et=M(l(d(e=>/*#__PURE__*/t.createElement(Q,r({},e,{name:"Circle"})),!0,["Circle"]))),nt=M(l(d(e=>/*#__PURE__*/t.createElement(Q,r({},e,{name:"Placemark"})),!0,["Placemark"]))),ot=M(l(d(e=>/*#__PURE__*/t.createElement(Q,r({},e,{name:"Polygon"})),!0,["Polygon"]))),st=M(l(d(e=>/*#__PURE__*/t.createElement(Q,r({},e,{name:"Polyline"})),!0,["Polyline"]))),rt=M(l(d(e=>/*#__PURE__*/t.createElement(Q,r({},e,{name:"Rectangle"})),!0,["Rectangle"])));export{B as Button,et as Circle,H as Clusterer,A as FullscreenControl,tt as GeoObject,L as GeolocationControl,$ as ListBox,N as ListBoxItem,S as Map,K as ObjectManager,U as Panorama,nt as Placemark,ot as Polygon,st as Polyline,rt as Rectangle,Z as RouteButton,z as RouteEditor,G as RoutePanel,I as RulerControl,W as SearchControl,F as TrafficControl,q as TypeSelector,y as YMaps,Y as ZoomControl,p as useYMaps,d as withYMaps};
//# sourceMappingURL=react-yandex-maps.modern.mjs.map
